{
  "$ref": "#/definitions/CrisisCleanupConfig",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "DatabaseConfig": {
      "additionalProperties": false,
      "properties": {
        "engineVersion": {
          "type": "string"
        },
        "ioOptimized": {
          "type": "boolean"
        },
        "maxAcu": {
          "type": "number",
          "default": 1
        }
      },
      "required": [
        "ioOptimized"
      ],
      "type": "object"
    },
    "EKSConfig": {
      "additionalProperties": false,
      "properties": {
        "coreDnsVersion": {
          "type": "string"
        },
        "defaultSecretsEncryption": {
          "type": "boolean"
        },
        "ebsCsiVersion": {
          "type": "string"
        },
        "k8s": {
          "$ref": "#/definitions/KubeConfig"
        },
        "kubeProxyVersion": {
          "type": "string"
        },
        "platformArns": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "vpcCniVersion": {
          "type": "string"
        }
      },
      "required": [
        "platformArns"
      ],
      "type": "object"
    },
    "KubeConfig": {
      "additionalProperties": false,
      "properties": {
        "version": {
          "type": "string"
        }
      },
      "required": [
        "version"
      ],
      "type": "object"
    },
    "ApiStackConfig": {
      "additionalProperties": false,
      "properties": {
        "codeStarConnectionArn": {
          "type": "string"
        },
        "database": {
          "$ref": "#/definitions/DatabaseConfig"
        },
        "eks": {
          "$ref": "#/definitions/EKSConfig"
        },
        "isolateDatabase": {
          "type": "boolean"
        },
        "kubecostToken": {
          "type": "string"
        }
      },
      "required": [
        "eks"
      ],
      "type": "object"
    },
    "ApiAppConfig": {
      "additionalProperties": false,
      "properties": {
        "ccu": {
          "additionalProperties": false,
          "properties": {
            "apiUrl": {
              "type": "string"
            },
            "forceDocker": {
              "type": "boolean"
            },
            "newrelicDisable": {
              "type": "boolean"
            },
            "webUrl": {
              "type": "string"
            }
          },
          "required": [
            "newrelicDisable",
            "webUrl",
            "apiUrl",
            "forceDocker"
          ],
          "type": "object"
        },
        "celery": {
          "additionalProperties": false,
          "properties": {
            "alwaysEager": {
              "type": "boolean"
            }
          },
          "required": [
            "alwaysEager"
          ],
          "type": "object"
        },
        "connect": {
          "additionalProperties": false,
          "properties": {
            "instanceId": {
              "type": "string"
            }
          },
          "required": [
            "instanceId"
          ],
          "type": "object"
        },
        "django": {
          "additionalProperties": false,
          "properties": {
            "accountAllowRegistration": {
              "type": "string"
            },
            "allowedHosts": {
              "type": "string"
            },
            "csrfCookieSecure": {
              "type": "boolean"
            },
            "emailBackend": {
              "type": "string"
            },
            "secureSslRedirect": {
              "type": "boolean"
            },
            "sessionCookieSecure": {
              "type": "boolean"
            },
            "settingsModule": {
              "type": "string"
            }
          },
          "required": [
            "csrfCookieSecure",
            "sessionCookieSecure",
            "emailBackend",
            "settingsModule"
          ],
          "type": "object"
        },
        "elasticSearch": {
          "additionalProperties": false,
          "properties": {
            "host": {
              "type": "string"
            }
          },
          "required": [
            "host"
          ],
          "type": "object"
        },
        "newRelic": {
          "additionalProperties": false,
          "properties": {
            "configFile": {
              "type": "string"
            },
            "environment": {
              "$ref": "#/definitions/Stage"
            }
          },
          "required": [
          ],
          "type": "object"
        },
        "phone": {
          "additionalProperties": false,
          "properties": {
            "checkTimezone": {
              "type": "boolean"
            }
          },
          "required": [
            "checkTimezone"
          ],
          "type": "object"
        },
        "sentry": {
          "additionalProperties": false,
          "properties": {
            "traceExcludeUrls": {
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          },
          "required": [
            "traceExcludeUrls"
          ],
          "type": "object"
        }
      },
      "required": [],
      "type": "object"
    },
    "ApiAppSecrets": {
      "additionalProperties": false,
      "properties": {
        "aws": {
          "additionalProperties": false,
          "properties": {
            "accessKeyId": {
              "type": "string"
            },
            "defaultRegion": {
              "type": "string"
            },
            "dynamoStage": {
              "type": "string"
            },
            "secretAccessKey": {
              "type": "string"
            }
          },
          "required": [
            "dynamoStage",
            "accessKeyId",
            "secretAccessKey",
            "defaultRegion"
          ],
          "type": "object"
        },
        "cloudfront": {
          "additionalProperties": false,
          "properties": {
            "privateKey": {
              "type": "string"
            },
            "publicKey": {
              "type": "string"
            }
          },
          "required": [
            "publicKey",
            "privateKey"
          ],
          "type": "object"
        },
        "connectFirst": {
          "additionalProperties": false,
          "properties": {
            "password": {
              "type": "string"
            }
          },
          "required": [
            "password"
          ],
          "type": "object"
        },
        "django": {
          "additionalProperties": false,
          "properties": {
            "adminUrl": {
              "type": "string"
            },
            "mandrill": {
              "additionalProperties": false,
              "properties": {
                "apiKey": {
                  "type": "string"
                }
              },
              "required": [
                "apiKey"
              ],
              "type": "object"
            },
            "secretKey": {
              "type": "string"
            }
          },
          "required": [
            "adminUrl",
            "secretKey",
            "mandrill"
          ],
          "type": "object"
        },
        "jwt": {
          "additionalProperties": false,
          "properties": {
            "privateKey": {
              "type": "string"
            },
            "publicKey": {
              "type": "string"
            }
          },
          "required": [
            "publicKey",
            "privateKey"
          ],
          "type": "object"
        },
        "postgres": {
          "additionalProperties": false,
          "properties": {
            "dbname": {
              "type": "string"
            },
            "host": {
              "type": "string"
            },
            "password": {
              "type": "string"
            },
            "port": {
              "type": [
                "string",
                "number"
              ]
            },
            "user": {
              "type": "string"
            }
          },
          "required": [
            "dbname",
            "host",
            "password",
            "user",
            "port"
          ],
          "type": "object"
        },
        "redis": {
          "additionalProperties": false,
          "properties": {
            "host": {
              "type": "string"
            },
            "hostReplicas": {
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          },
          "required": [
            "host",
            "hostReplicas"
          ],
          "type": "object"
        },
        "saml": {
          "additionalProperties": false,
          "properties": {
            "awsProvider": {
              "type": "string"
            },
            "awsRole": {
              "type": "string"
            }
          },
          "required": [
            "awsRole",
            "awsProvider"
          ],
          "type": "object"
        },
        "zendesk": {
          "additionalProperties": false,
          "properties": {
            "apiKey": {
              "type": "string"
            }
          },
          "required": [
            "apiKey"
          ],
          "type": "object"
        }
      },
      "required": [
        "postgres",
        "redis",
        "jwt",
        "zendesk",
        "connectFirst",
        "aws",
        "cloudfront",
        "saml",
        "django"
      ],
      "type": "object"
    },
    "ApiConfig": {
      "additionalProperties": false,
      "properties": {
        "config": {
          "$ref": "#/definitions/ApiAppConfig"
        },
        "secrets": {
          "$ref": "#/definitions/ApiAppSecrets"
        }
      },
      "required": [],
      "type": "object"
    },
    "CdkEnvironment": {
      "additionalProperties": false,
      "properties": {
        "account": {
          "type": "string"
        },
        "region": {
          "type": "string"
        }
      },
      "required": [
        "account",
        "region"
      ],
      "type": "object"
    },
    "ApiObjectMetadata": {
      "additionalProperties": {
        "description": "Additional metadata attributes."
      },
      "description": "Metadata associated with this object.",
      "properties": {
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "default": "- No annotations.",
          "description": "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects.",
          "type": "object"
        },
        "finalizers": {
          "default": "- No finalizers.",
          "description": "Namespaced keys that tell Kubernetes to wait until specific conditions are met before it fully deletes resources marked for deletion.\n\nMust be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "default": "- No labels.",
          "description": "Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services.",
          "type": "object"
        },
        "name": {
          "default": "- an app-unique name generated by the chart",
          "description": "The unique, namespace-global, name of this object inside the Kubernetes cluster.\n\nNormally, you shouldn't specify names for objects and let the CDK generate a name for you that is application-unique. The names CDK generates are composed from the construct path components, separated by dots and a suffix that is based on a hash of the entire path, to ensure uniqueness.\n\nYou can supply custom name allocation logic by overriding the `chart.generateObjectName` method.\n\nIf you use an explicit name here, bear in mind that this reduces the composability of your construct because it won't be possible to include more than one instance in any app. Therefore it is highly recommended to leave this unspecified.",
          "type": "string"
        },
        "namespace": {
          "default": "undefined (will be assigned to the 'default' namespace)",
          "description": "Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces",
          "type": "string"
        },
        "ownerReferences": {
          "default": "- automatically set by Kubernetes",
          "description": "List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.\n\nKubernetes sets the value of this field automatically for objects that are dependents of other objects like ReplicaSets, DaemonSets, Deployments, Jobs and CronJobs, and ReplicationControllers. You can also configure these relationships manually by changing the value of this field. However, you usually don't need to and can allow Kubernetes to automatically manage the relationships.",
          "items": {
            "$ref": "#/definitions/OwnerReference"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ComponentScalingProps": {
      "additionalProperties": false,
      "properties": {
        "cpuUtilPercent": {
          "type": "number"
        },
        "hpa": {
          "$ref": "#/definitions/HorizontalPodAutoscalerProps",
          "description": "Escape hatch"
        },
        "maxReplicas": {
          "description": "The maximum number of replicas that can be scaled up to.",
          "type": "number"
        },
        "memUtilPercent": {
          "type": "number"
        },
        "minReplicas": {
          "default": 1,
          "description": "The minimum number of replicas that can be scaled down to.\n\nCan be set to 0 if the alpha feature gate `HPAScaleToZero` is enabled and at least one Object or External metric is configured.",
          "type": "number"
        },
        "target": {
          "$ref": "#/definitions/IScalable",
          "description": "The workload to scale up or down.\n\nScalable workload types:\n* Deployment\n* StatefulSet"
        }
      },
      "required": [
        "maxReplicas"
      ],
      "type": "object"
    },
    "ContainerImageProps": {
      "additionalProperties": false,
      "properties": {
        "pullPolicy": {
          "anyOf": [
            {
              "$ref": "#/definitions/ImagePullPolicy"
            },
            {
              "type": "string"
            }
          ]
        },
        "repository": {
          "type": "string"
        },
        "tag": {
          "type": "string"
        }
      },
      "required": [
        "repository",
        "tag"
      ],
      "type": "object"
    },
    "ContainerLifecycle": {
      "additionalProperties": false,
      "description": "Container lifecycle properties.",
      "properties": {
        "postStart": {
          "$ref": "#/definitions/Handler",
          "default": "- No post start handler.",
          "description": "This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT."
        },
        "preStop": {
          "$ref": "#/definitions/Handler",
          "default": "- No pre stop handler.",
          "description": "This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod's termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period. No parameters are passed to the handler."
        }
      },
      "type": "object"
    },
    "ContainerPort": {
      "additionalProperties": false,
      "description": "Represents a network port in a single container.",
      "properties": {
        "hostIp": {
          "default": "- 127.0.0.1.",
          "description": "What host IP to bind the external port to.",
          "type": "string"
        },
        "hostPort": {
          "default": "- auto generated by kubernetes and might change on restarts.",
          "description": "Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. Most containers do not need this.",
          "type": "number"
        },
        "name": {
          "default": "- port is not named.",
          "description": "If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.",
          "type": "string"
        },
        "number": {
          "description": "Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.",
          "type": "number"
        },
        "protocol": {
          "$ref": "#/definitions/Protocol",
          "default": "Protocol.TCP",
          "description": "Protocol for port. Must be UDP, TCP, or SCTP. Defaults to \"TCP\"."
        }
      },
      "required": [
        "number"
      ],
      "type": "object"
    },
    "ContainerProps": {
      "additionalProperties": false,
      "description": "Properties for creating a container.",
      "properties": {
        "args": {
          "default": [],
          "description": "Arguments to the entrypoint. The docker image's CMD is used if `command` is not provided.\n\nVariable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not.\n\nCannot be updated.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "command": {
          "default": "- The docker image's ENTRYPOINT.",
          "description": "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "envFrom": {
          "default": "- No sources.",
          "description": "List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the `envVariables` property with a duplicate key will take precedence.",
          "items": {
            "$ref": "#/definitions/EnvFrom"
          },
          "type": "array"
        },
        "envVariables": {
          "additionalProperties": {
            "$ref": "#/definitions/EnvValue"
          },
          "default": "- No environment variables.",
          "description": "Environment variables to set in the container.",
          "type": "object"
        },
        "image": {
          "description": "Docker image name.",
          "type": "string"
        },
        "imagePullPolicy": {
          "$ref": "#/definitions/ImagePullPolicy",
          "default": "ImagePullPolicy.ALWAYS",
          "description": "Image pull policy for this container"
        },
        "lifecycle": {
          "$ref": "#/definitions/ContainerLifecycle",
          "description": "Describes actions that the management system should take in response to container lifecycle events."
        },
        "liveness": {
          "$ref": "#/definitions/Probe",
          "default": "- no liveness probe is defined",
          "description": "Periodic probe of container liveness. Container will be restarted if the probe fails."
        },
        "name": {
          "default": "main",
          "description": "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
          "type": "string"
        },
        "port": {
          "deprecated": "- use `portNumber`.",
          "type": "number"
        },
        "portNumber": {
          "default": "- Only the ports mentiond in the `ports` property are exposed.",
          "description": "Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.\n\nThis is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the `ports` property.\n\nThis port is added to the list of ports mentioned in the `ports` property.",
          "type": "number"
        },
        "ports": {
          "default": "- Only the port mentioned in the `portNumber` property is exposed.",
          "description": "List of ports to expose from this container.",
          "items": {
            "$ref": "#/definitions/ContainerPort"
          },
          "type": "array"
        },
        "readiness": {
          "$ref": "#/definitions/Probe",
          "default": "- no readiness probe is defined",
          "description": "Determines when the container is ready to serve traffic."
        },
        "resources": {
          "$ref": "#/definitions/ContainerResources",
          "default": "   cpu:\n     request: 1000 millis\n     limit: 1500 millis\n   memory:\n     request: 512 mebibytes\n     limit: 2048 mebibytes",
          "description": "Compute resources (CPU and memory requests and limits) required by the container"
        },
        "securityContext": {
          "$ref": "#/definitions/ContainerSecurityContextProps",
          "default": "  ensureNonRoot: true\n  privileged: false\n  readOnlyRootFilesystem: true\n  allowPrivilegeEscalation: false\n  user: 25000\n  group: 26000",
          "description": "SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod's security context."
        },
        "startup": {
          "$ref": "#/definitions/Probe",
          "default": "- If a port is provided, then knocks on that port\nto determine when the container is ready for readiness and\nliveness probe checks.\nOtherwise, no startup probe is defined.",
          "description": "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully"
        },
        "volumeMounts": {
          "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
          "items": {
            "$ref": "#/definitions/VolumeMount"
          },
          "type": "array"
        },
        "workingDir": {
          "default": "- The container runtime's default.",
          "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
          "type": "string"
        }
      },
      "required": [
        "image"
      ],
      "type": "object"
    },
    "ContainerResources": {
      "additionalProperties": false,
      "description": "CPU and memory compute resources",
      "properties": {
        "cpu": {
          "$ref": "#/definitions/CpuResources"
        },
        "ephemeralStorage": {
          "$ref": "#/definitions/EphemeralStorageResources"
        },
        "memory": {
          "$ref": "#/definitions/MemoryResources"
        }
      },
      "type": "object"
    },
    "ContainerSecurityContextProps": {
      "additionalProperties": false,
      "description": "Properties for `ContainerSecurityContext`",
      "properties": {
        "allowPrivilegeEscalation": {
          "default": false,
          "description": "Whether a process can gain more privileges than its parent process.",
          "type": "boolean"
        },
        "ensureNonRoot": {
          "default": true,
          "description": "Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does.",
          "type": "boolean"
        },
        "group": {
          "default": "- 26000. An arbitrary number bigger than 9999 is selected here.\nThis is so that the container is blocked to access host files even if\nsomehow it manages to get access to host file system.",
          "description": "The GID to run the entrypoint of the container process.",
          "type": "number"
        },
        "privileged": {
          "default": false,
          "description": "Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host.",
          "type": "boolean"
        },
        "readOnlyRootFilesystem": {
          "default": true,
          "description": "Whether this container has a read-only root filesystem.",
          "type": "boolean"
        },
        "user": {
          "default": "- 25000. An arbitrary number bigger than 9999 is selected here.\nThis is so that the container is blocked to access host files even if\nsomehow it manages to get access to host file system.",
          "description": "The UID to run the entrypoint of the container process.",
          "type": "number"
        }
      },
      "type": "object"
    },
    "Cpu": {
      "additionalProperties": false,
      "description": "Represents the amount of CPU. The amount can be passed as millis or units.",
      "properties": {
        "amount": {
          "type": "string"
        }
      },
      "required": [
        "amount"
      ],
      "type": "object"
    },
    "CpuResources": {
      "additionalProperties": false,
      "description": "CPU request and limit",
      "properties": {
        "limit": {
          "$ref": "#/definitions/Cpu"
        },
        "request": {
          "$ref": "#/definitions/Cpu"
        }
      },
      "type": "object"
    },
    "DeploymentProps": {
      "additionalProperties": false,
      "properties": {
        "automountServiceAccountToken": {
          "default": false,
          "description": "Indicates whether a service account token should be automatically mounted.",
          "type": "boolean"
        },
        "containerDefaults": {
          "additionalProperties": false,
          "properties": {
            "args": {
              "default": [],
              "description": "Arguments to the entrypoint. The docker image's CMD is used if `command` is not provided.\n\nVariable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not.\n\nCannot be updated.",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "command": {
              "default": "- The docker image's ENTRYPOINT.",
              "description": "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "envFrom": {
              "default": "- No sources.",
              "description": "List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the `envVariables` property with a duplicate key will take precedence.",
              "items": {
                "$ref": "#/definitions/EnvFrom"
              },
              "type": "array"
            },
            "envVariables": {
              "additionalProperties": {
                "$ref": "#/definitions/EnvValue"
              },
              "default": "- No environment variables.",
              "description": "Environment variables to set in the container.",
              "type": "object"
            },
            "image": {
              "description": "Docker image name.",
              "type": "string"
            },
            "imagePullPolicy": {
              "$ref": "#/definitions/ImagePullPolicy",
              "default": "ImagePullPolicy.ALWAYS",
              "description": "Image pull policy for this container"
            },
            "lifecycle": {
              "$ref": "#/definitions/ContainerLifecycle",
              "description": "Describes actions that the management system should take in response to container lifecycle events."
            },
            "liveness": {
              "$ref": "#/definitions/Probe",
              "default": "- no liveness probe is defined",
              "description": "Periodic probe of container liveness. Container will be restarted if the probe fails."
            },
            "name": {
              "default": "main",
              "description": "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
              "type": "string"
            },
            "port": {
              "deprecated": "- use `portNumber`.",
              "type": "number"
            },
            "portNumber": {
              "default": "- Only the ports mentiond in the `ports` property are exposed.",
              "description": "Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.\n\nThis is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the `ports` property.\n\nThis port is added to the list of ports mentioned in the `ports` property.",
              "type": "number"
            },
            "ports": {
              "default": "- Only the port mentioned in the `portNumber` property is exposed.",
              "description": "List of ports to expose from this container.",
              "items": {
                "$ref": "#/definitions/ContainerPort"
              },
              "type": "array"
            },
            "readiness": {
              "$ref": "#/definitions/Probe",
              "default": "- no readiness probe is defined",
              "description": "Determines when the container is ready to serve traffic."
            },
            "resources": {
              "$ref": "#/definitions/ContainerResources",
              "default": "   cpu:\n     request: 1000 millis\n     limit: 1500 millis\n   memory:\n     request: 512 mebibytes\n     limit: 2048 mebibytes",
              "description": "Compute resources (CPU and memory requests and limits) required by the container"
            },
            "securityContext": {
              "$ref": "#/definitions/ContainerSecurityContextProps",
              "default": "  ensureNonRoot: true\n  privileged: false\n  readOnlyRootFilesystem: true\n  allowPrivilegeEscalation: false\n  user: 25000\n  group: 26000",
              "description": "SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod's security context."
            },
            "startup": {
              "$ref": "#/definitions/Probe",
              "default": "- If a port is provided, then knocks on that port\nto determine when the container is ready for readiness and\nliveness probe checks.\nOtherwise, no startup probe is defined.",
              "description": "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully"
            },
            "volumeMounts": {
              "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
              "items": {
                "$ref": "#/definitions/VolumeMount"
              },
              "type": "array"
            },
            "workingDir": {
              "default": "- The container runtime's default.",
              "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
              "type": "string"
            }
          },
          "type": "object"
        },
        "containers": {
          "default": "- No containers. Note that a pod spec must include at least one container.",
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod.\n\nYou can add additionnal containers using `podSpec.addContainer()`",
          "items": {
            "$ref": "#/definitions/ContainerProps"
          },
          "type": "array"
        },
        "dns": {
          "$ref": "#/definitions/PodDnsProps",
          "default": " policy: DnsPolicy.CLUSTER_FIRST\n hostnameAsFQDN: false",
          "description": "DNS settings for the pod."
        },
        "dockerRegistryAuth": {
          "$ref": "#/definitions/ISecret",
          "default": "- No auth. Images are assumed to be publicly available.",
          "description": "A secret containing docker credentials for authenticating to a registry."
        },
        "hostAliases": {
          "description": "HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.",
          "items": {
            "$ref": "#/definitions/HostAlias"
          },
          "type": "array"
        },
        "hostNetwork": {
          "default": false,
          "description": "Host network for the pod.",
          "type": "boolean"
        },
        "image": {
          "$ref": "#/definitions/ContainerImageProps"
        },
        "initContainers": {
          "default": "- No init containers.",
          "description": "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion.\n\nInit containers cannot currently be added ,removed or updated.",
          "items": {
            "$ref": "#/definitions/ContainerProps"
          },
          "type": "array"
        },
        "isolate": {
          "default": false,
          "description": "Isolates the pod. This will prevent any ingress or egress connections to / from this pod. You can however allow explicit connections post instantiation by using the `.connections` property.",
          "type": "boolean"
        },
        "metadata": {
          "$ref": "#/definitions/ApiObjectMetadata",
          "description": "Metadata that all persisted resources must have, which includes all objects users must create."
        },
        "podMetadata": {
          "$ref": "#/definitions/ApiObjectMetadata",
          "description": "The pod metadata of this workload."
        },
        "probes": {
          "additionalProperties": false,
          "properties": {
            "liveness": {
              "$ref": "#/definitions/Probe",
              "default": "- no liveness probe is defined",
              "description": "Periodic probe of container liveness. Container will be restarted if the probe fails."
            },
            "readiness": {
              "$ref": "#/definitions/Probe",
              "default": "- no readiness probe is defined",
              "description": "Determines when the container is ready to serve traffic."
            },
            "startup": {
              "$ref": "#/definitions/Probe",
              "default": "- If a port is provided, then knocks on that port\nto determine when the container is ready for readiness and\nliveness probe checks.\nOtherwise, no startup probe is defined.",
              "description": "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully"
            }
          },
          "type": "object"
        },
        "replicaCount": {
          "type": "number"
        },
        "restartPolicy": {
          "$ref": "#/definitions/RestartPolicy",
          "default": "RestartPolicy.ALWAYS",
          "description": "Restart policy for all containers within the pod."
        },
        "scaling": {
          "$ref": "#/definitions/ComponentScalingProps"
        },
        "securityContext": {
          "$ref": "#/definitions/PodSecurityContextProps",
          "default": "  fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS\n  ensureNonRoot: true",
          "description": "SecurityContext holds pod-level security attributes and common container settings."
        },
        "select": {
          "default": true,
          "description": "Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template.",
          "type": "boolean"
        },
        "serviceAccount": {
          "$ref": "#/definitions/IServiceAccount",
          "default": "- No service account.",
          "description": "A service account provides an identity for processes that run in a Pod.\n\nWhen you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default)."
        },
        "spread": {
          "default": false,
          "description": "Automatically spread pods across hostname and zones.",
          "type": "boolean"
        },
        "terminationGracePeriod": {
          "$ref": "#/definitions/Duration",
          "default": "Duration.seconds(30)",
          "description": "Grace period until the pod is terminated"
        },
        "volumes": {
          "default": "- No volumes.",
          "description": "List of volumes that can be mounted by containers belonging to the pod.\n\nYou can also add volumes later using `podSpec.addVolume()`",
          "items": {
            "$ref": "#/definitions/Volume"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DnsOption": {
      "additionalProperties": false,
      "description": "Custom DNS option.",
      "properties": {
        "name": {
          "description": "Option name.",
          "type": "string"
        },
        "value": {
          "default": "- No value.",
          "description": "Option value.",
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "DnsPolicy": {
      "description": "Pod DNS policies.",
      "enum": [
        "ClusterFirst",
        "ClusterFirstWithHostNet",
        "Default",
        "None"
      ],
      "type": "string"
    },
    "Duration": {
      "additionalProperties": false,
      "description": "Represents a length of time.\n\nThe amount can be specified either as a literal value (e.g: `10`) which cannot be negative.",
      "type": "object"
    },
    "EnvFrom": {
      "additionalProperties": false,
      "description": "A collection of env variables defined in other resources.",
      "type": "object"
    },
    "EnvValue": {
      "additionalProperties": false,
      "description": "Utility class for creating reading env values from various sources.",
      "properties": {
        "value": {},
        "valueFrom": {}
      },
      "type": "object"
    },
    "EphemeralStorageResources": {
      "additionalProperties": false,
      "description": "Emphemeral storage request and limit",
      "properties": {
        "limit": {
          "$ref": "#/definitions/Size"
        },
        "request": {
          "$ref": "#/definitions/Size"
        }
      },
      "type": "object"
    },
    "FrontendProps": {
      "additionalProperties": false,
      "properties": {
        "web": {
          "$ref": "#/definitions/DeploymentProps"
        }
      },
      "required": [
        "web"
      ],
      "type": "object"
    },
    "FsGroupChangePolicy": {
      "enum": [
        "OnRootMismatch",
        "Always"
      ],
      "type": "string"
    },
    "Handler": {
      "additionalProperties": false,
      "description": "Defines a specific action that should be taken.",
      "type": "object"
    },
    "HorizontalPodAutoscalerProps": {
      "additionalProperties": false,
      "description": "Properties for HorizontalPodAutoscaler",
      "properties": {
        "maxReplicas": {
          "description": "The maximum number of replicas that can be scaled up to.",
          "type": "number"
        },
        "metadata": {
          "$ref": "#/definitions/ApiObjectMetadata",
          "description": "Metadata that all persisted resources must have, which includes all objects users must create."
        },
        "metrics": {
          "default": "- If metrics are not provided, then the target resource\nconstraints (e.g. cpu limit) will be used as scaling metrics.",
          "description": "The metric conditions that trigger a scale up or scale down.",
          "items": {
            "$ref": "#/definitions/Metric"
          },
          "type": "array"
        },
        "minReplicas": {
          "default": 1,
          "description": "The minimum number of replicas that can be scaled down to.\n\nCan be set to 0 if the alpha feature gate `HPAScaleToZero` is enabled and at least one Object or External metric is configured.",
          "type": "number"
        },
        "scaleDown": {
          "$ref": "#/definitions/ScalingRules",
          "default": "- Scale down to minReplica count with a 5 minute stabilization window.",
          "description": "The scaling behavior when scaling down."
        },
        "scaleUp": {
          "$ref": "#/definitions/ScalingRules",
          "default": "- Is the higher of:\n* Increase no more than 4 pods per 60 seconds\n* Double the number of pods per 60 seconds",
          "description": "The scaling behavior when scaling up."
        },
        "target": {
          "$ref": "#/definitions/IScalable",
          "description": "The workload to scale up or down.\n\nScalable workload types:\n* Deployment\n* StatefulSet"
        }
      },
      "required": [
        "target",
        "maxReplicas"
      ],
      "type": "object"
    },
    "HostAlias": {
      "additionalProperties": false,
      "description": "HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's /etc/hosts file.",
      "properties": {
        "hostnames": {
          "description": "Hostnames for the chosen IP address.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "ip": {
          "description": "IP address of the host file entry.",
          "type": "string"
        }
      },
      "required": [
        "hostnames",
        "ip"
      ],
      "type": "object"
    },
    "IConstruct": {
      "additionalProperties": false,
      "description": "Represents a construct.",
      "properties": {
        "node": {
          "$ref": "#/definitions/Node",
          "description": "The tree node."
        }
      },
      "required": [
        "node"
      ],
      "type": "object"
    },
    "IScalable": {
      "additionalProperties": false,
      "description": "Represents a scalable workload.",
      "properties": {
        "hasAutoscaler": {
          "description": "If this is a target of an autoscaler.",
          "type": "boolean"
        }
      },
      "required": [
        "hasAutoscaler"
      ],
      "type": "object"
    },
    "ISecret": {
      "additionalProperties": false,
      "properties": {
        "apiGroup": {
          "description": "The group portion of the API version (e.g. `authorization.k8s.io`).",
          "type": "string"
        },
        "apiVersion": {
          "description": "The object's API version (e.g. \"authorization.k8s.io/v1\")",
          "type": "string"
        },
        "kind": {
          "description": "The object kind (e.g. \"Deployment\").",
          "type": "string"
        },
        "name": {
          "description": "The Kubernetes name of this resource.",
          "type": "string"
        },
        "node": {
          "$ref": "#/definitions/Node",
          "description": "The tree node."
        },
        "resourceName": {
          "description": "The unique, namespace-global, name of an object inside the Kubernetes cluster.\n\nIf this is omitted, the ApiResource should represent all objects of the given type.",
          "type": "string"
        },
        "resourceType": {
          "description": "The name of a resource type as it appears in the relevant API endpoint.",
          "type": "string"
        }
      },
      "required": [
        "apiGroup",
        "apiVersion",
        "kind",
        "name",
        "node",
        "resourceType"
      ],
      "type": "object"
    },
    "IServiceAccount": {
      "additionalProperties": false,
      "properties": {
        "apiGroup": {
          "description": "The group portion of the API version (e.g. `authorization.k8s.io`).",
          "type": "string"
        },
        "apiVersion": {
          "description": "The object's API version (e.g. \"authorization.k8s.io/v1\")",
          "type": "string"
        },
        "kind": {
          "description": "The object kind (e.g. \"Deployment\").",
          "type": "string"
        },
        "name": {
          "description": "The Kubernetes name of this resource.",
          "type": "string"
        },
        "node": {
          "$ref": "#/definitions/Node",
          "description": "The tree node."
        },
        "resourceName": {
          "description": "The unique, namespace-global, name of an object inside the Kubernetes cluster.\n\nIf this is omitted, the ApiResource should represent all objects of the given type.",
          "type": "string"
        },
        "resourceType": {
          "description": "The name of a resource type as it appears in the relevant API endpoint.",
          "type": "string"
        }
      },
      "required": [
        "apiGroup",
        "apiVersion",
        "kind",
        "name",
        "node",
        "resourceType"
      ],
      "type": "object"
    },
    "ImagePullPolicy": {
      "enum": [
        "Always",
        "IfNotPresent",
        "Never"
      ],
      "type": "string"
    },
    "MemoryResources": {
      "additionalProperties": false,
      "description": "Memory request and limit",
      "properties": {
        "limit": {
          "$ref": "#/definitions/Size"
        },
        "request": {
          "$ref": "#/definitions/Size"
        }
      },
      "type": "object"
    },
    "Metric": {
      "additionalProperties": false,
      "description": "A metric condition that HorizontalPodAutoscaler's scale on.",
      "properties": {
        "type": {
          "type": "string"
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "MountPropagation": {
      "enum": [
        "None",
        "HostToContainer",
        "Bidirectional"
      ],
      "type": "string"
    },
    "Node": {
      "additionalProperties": false,
      "description": "Represents the construct node in the scope tree.",
      "properties": {
        "id": {
          "description": "The id of this construct within the current scope.\n\nThis is a a scope-unique id. To obtain an app-unique id for this construct, use `addr`.",
          "type": "string"
        },
        "scope": {
          "$ref": "#/definitions/IConstruct",
          "description": "Returns the scope in which this construct is defined.\n\nThe value is `undefined` at the root of the construct scope tree."
        }
      },
      "required": [
        "id"
      ],
      "type": "object"
    },
    "OwnerReference": {
      "additionalProperties": false,
      "description": "OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.",
      "properties": {
        "apiVersion": {
          "description": "API version of the referent.",
          "type": "string"
        },
        "blockOwnerDeletion": {
          "default": "false. To set this field, a user needs \"delete\" permission of the\nowner, otherwise 422 (Unprocessable Entity) will be returned.",
          "description": "If true, AND if the owner has the \"foregroundDeletion\" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs \"delete\" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.",
          "type": "boolean"
        },
        "controller": {
          "description": "If true, this reference points to the managing controller.",
          "type": "boolean"
        },
        "kind": {
          "description": "Kind of the referent.",
          "type": "string"
        },
        "name": {
          "description": "Name of the referent.",
          "type": "string"
        },
        "uid": {
          "description": "UID of the referent.",
          "type": "string"
        }
      },
      "required": [
        "apiVersion",
        "kind",
        "name",
        "uid"
      ],
      "type": "object"
    },
    "PodDnsProps": {
      "additionalProperties": false,
      "description": "Properties for `PodDns`.",
      "properties": {
        "hostname": {
          "default": "- Set to a system-defined value.",
          "description": "Specifies the hostname of the Pod.",
          "type": "string"
        },
        "hostnameAsFQDN": {
          "default": false,
          "description": "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect.",
          "type": "boolean"
        },
        "nameservers": {
          "description": "A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \"NONE\", the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "options": {
          "description": "List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed.",
          "items": {
            "$ref": "#/definitions/DnsOption"
          },
          "type": "array"
        },
        "policy": {
          "$ref": "#/definitions/DnsPolicy",
          "default": "DnsPolicy.CLUSTER_FIRST",
          "description": "Set DNS policy for the pod.\n\nIf policy is set to `None`, other configuration must be supplied."
        },
        "searches": {
          "description": "A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed.\n\nKubernetes allows for at most 6 search domains.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "subdomain": {
          "default": "- No subdomain.",
          "description": "If specified, the fully qualified Pod hostname will be \"<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>\".",
          "type": "string"
        }
      },
      "type": "object"
    },
    "PodSecurityContextProps": {
      "additionalProperties": false,
      "description": "Properties for `PodSecurityContext`",
      "properties": {
        "ensureNonRoot": {
          "default": true,
          "description": "Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does.",
          "type": "boolean"
        },
        "fsGroup": {
          "default": "- Volume ownership is not changed.",
          "description": "Modify the ownership and permissions of pod volumes to this GID.",
          "type": "number"
        },
        "fsGroupChangePolicy": {
          "$ref": "#/definitions/FsGroupChangePolicy",
          "default": "FsGroupChangePolicy.ALWAYS",
          "description": "Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir."
        },
        "group": {
          "default": "- Group configured by container runtime",
          "description": "The GID to run the entrypoint of the container process.",
          "type": "number"
        },
        "sysctls": {
          "default": "- No sysctls",
          "description": "Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch.",
          "items": {
            "$ref": "#/definitions/Sysctl"
          },
          "type": "array"
        },
        "user": {
          "default": "- User specified in image metadata",
          "description": "The UID to run the entrypoint of the container process.",
          "type": "number"
        }
      },
      "type": "object"
    },
    "Probe": {
      "additionalProperties": false,
      "description": "Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.",
      "type": "object"
    },
    "Protocol": {
      "description": "Network protocols.",
      "enum": [
        "TCP",
        "UDP",
        "SCTP"
      ],
      "type": "string"
    },
    "Replicas": {
      "additionalProperties": false,
      "description": "The amount of replicas that will change.",
      "type": "object"
    },
    "RestartPolicy": {
      "description": "Restart policy for all containers within the pod.",
      "enum": [
        "Always",
        "OnFailure",
        "Never"
      ],
      "type": "string"
    },
    "ScalingPolicy": {
      "additionalProperties": false,
      "properties": {
        "duration": {
          "$ref": "#/definitions/Duration",
          "default": "- 15 seconds",
          "description": "The amount of time the scaling policy has to continue scaling before the target metric must be revalidated.\n\nMust be greater than 0 seconds and no longer than 30 minutes."
        },
        "replicas": {
          "$ref": "#/definitions/Replicas",
          "description": "The type and quantity of replicas to change."
        }
      },
      "required": [
        "replicas"
      ],
      "type": "object"
    },
    "ScalingRules": {
      "additionalProperties": false,
      "description": "Defines the scaling behavior for one direction.",
      "properties": {
        "policies": {
          "default": "* Scale up\n  * Increase no more than 4 pods per 60 seconds\n  * Double the number of pods per 60 seconds\n* Scale down\n  * Decrease to minReplica count",
          "description": "The scaling policies.",
          "items": {
            "$ref": "#/definitions/ScalingPolicy"
          },
          "type": "array"
        },
        "stabilizationWindow": {
          "$ref": "#/definitions/Duration",
          "default": "* On scale down no stabilization is performed.\n* On scale up stabilization is performed for 5 minutes.",
          "description": "Defines the window of past metrics that the autoscaler should consider when calculating wether or not autoscaling should occur.\n\nMinimum duration is 1 second, max is 1 hour."
        },
        "strategy": {
          "$ref": "#/definitions/ScalingStrategy",
          "default": "MAX_CHANGE",
          "description": "The strategy to use when scaling."
        }
      },
      "type": "object"
    },
    "ScalingStrategy": {
      "enum": [
        "Max",
        "Min",
        "Disabled"
      ],
      "type": "string"
    },
    "Size": {
      "additionalProperties": false,
      "description": "Represents the amount of digital storage.\n\nThe amount can be specified either as a literal value (e.g: `10`) which cannot be negative.\n\nWhen the amount is passed as a token, unit conversion is not possible.",
      "type": "object"
    },
    "Sysctl": {
      "additionalProperties": false,
      "description": "Sysctl defines a kernel parameter to be set",
      "properties": {
        "name": {
          "description": "Name of a property to set",
          "type": "string"
        },
        "value": {
          "description": "Value of a property to set",
          "type": "string"
        }
      },
      "required": [
        "name",
        "value"
      ],
      "type": "object"
    },
    "Volume": {
      "additionalProperties": false,
      "description": "Volume represents a named volume in a pod that may be accessed by any container in the pod.\n\nDocker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes).\n\nA Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously.\n\nAt its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used.\n\nTo use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field).\n\nA process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes",
      "properties": {
        "name": {
          "type": "string"
        },
        "node": {
          "$ref": "#/definitions/Node",
          "description": "The tree node."
        }
      },
      "required": [
        "name",
        "node"
      ],
      "type": "object"
    },
    "VolumeMount": {
      "additionalProperties": false,
      "description": "Mount a volume from the pod to the container.",
      "properties": {
        "path": {
          "description": "Path within the container at which the volume should be mounted. Must not contain ':'.",
          "type": "string"
        },
        "propagation": {
          "$ref": "#/definitions/MountPropagation",
          "default": "MountPropagation.NONE",
          "description": "Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used.\n\nMount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node."
        },
        "readOnly": {
          "default": false,
          "description": "Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.",
          "type": "boolean"
        },
        "subPath": {
          "default": "\"\" the volume's root",
          "description": "Path within the volume from which the container's volume should be mounted.).",
          "type": "string"
        },
        "subPathExpr": {
          "default": "\"\" volume's root.",
          "description": "Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to \"\" (volume's root).\n\n`subPathExpr` and `subPath` are mutually exclusive.",
          "type": "string"
        },
        "volume": {
          "$ref": "#/definitions/Volume",
          "description": "The volume to mount."
        }
      },
      "required": [
        "volume",
        "path"
      ],
      "type": "object"
    },
    "CrisisCleanupConfig": {
      "additionalProperties": false,
      "properties": {
        "api": {
          "$ref": "#/definitions/ApiConfig"
        },
        "ccuStage": {
          "$ref": "#/definitions/Stage"
        },
        "cdkEnvironment": {
          "$ref": "#/definitions/CdkEnvironment"
        },
        "apiStack": {
          "$ref": "#/definitions/ApiStackConfig"
        },
        "chart": {
          "additionalProperties": false,
          "properties": {
            "apiImage": {
              "$ref": "#/definitions/ContainerImageProps"
            },
            "asgi": {
              "additionalProperties": false,
              "properties": {
                "automountServiceAccountToken": {
                  "default": false,
                  "description": "Indicates whether a service account token should be automatically mounted.",
                  "type": "boolean"
                },
                "containerDefaults": {
                  "additionalProperties": false,
                  "properties": {
                    "args": {
                      "default": [],
                      "description": "Arguments to the entrypoint. The docker image's CMD is used if `command` is not provided.\n\nVariable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not.\n\nCannot be updated.",
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "command": {
                      "default": "- The docker image's ENTRYPOINT.",
                      "description": "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "envFrom": {
                      "default": "- No sources.",
                      "description": "List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the `envVariables` property with a duplicate key will take precedence.",
                      "items": {
                        "$ref": "#/definitions/EnvFrom"
                      },
                      "type": "array"
                    },
                    "envVariables": {
                      "additionalProperties": {
                        "$ref": "#/definitions/EnvValue"
                      },
                      "default": "- No environment variables.",
                      "description": "Environment variables to set in the container.",
                      "type": "object"
                    },
                    "image": {
                      "description": "Docker image name.",
                      "type": "string"
                    },
                    "imagePullPolicy": {
                      "$ref": "#/definitions/ImagePullPolicy",
                      "default": "ImagePullPolicy.ALWAYS",
                      "description": "Image pull policy for this container"
                    },
                    "lifecycle": {
                      "$ref": "#/definitions/ContainerLifecycle",
                      "description": "Describes actions that the management system should take in response to container lifecycle events."
                    },
                    "liveness": {
                      "$ref": "#/definitions/Probe",
                      "default": "- no liveness probe is defined",
                      "description": "Periodic probe of container liveness. Container will be restarted if the probe fails."
                    },
                    "name": {
                      "default": "main",
                      "description": "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
                      "type": "string"
                    },
                    "port": {
                      "deprecated": "- use `portNumber`.",
                      "type": "number"
                    },
                    "portNumber": {
                      "default": "- Only the ports mentiond in the `ports` property are exposed.",
                      "description": "Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.\n\nThis is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the `ports` property.\n\nThis port is added to the list of ports mentioned in the `ports` property.",
                      "type": "number"
                    },
                    "ports": {
                      "default": "- Only the port mentioned in the `portNumber` property is exposed.",
                      "description": "List of ports to expose from this container.",
                      "items": {
                        "$ref": "#/definitions/ContainerPort"
                      },
                      "type": "array"
                    },
                    "readiness": {
                      "$ref": "#/definitions/Probe",
                      "default": "- no readiness probe is defined",
                      "description": "Determines when the container is ready to serve traffic."
                    },
                    "resources": {
                      "$ref": "#/definitions/ContainerResources",
                      "default": "   cpu:\n     request: 1000 millis\n     limit: 1500 millis\n   memory:\n     request: 512 mebibytes\n     limit: 2048 mebibytes",
                      "description": "Compute resources (CPU and memory requests and limits) required by the container"
                    },
                    "securityContext": {
                      "$ref": "#/definitions/ContainerSecurityContextProps",
                      "default": "  ensureNonRoot: true\n  privileged: false\n  readOnlyRootFilesystem: true\n  allowPrivilegeEscalation: false\n  user: 25000\n  group: 26000",
                      "description": "SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod's security context."
                    },
                    "startup": {
                      "$ref": "#/definitions/Probe",
                      "default": "- If a port is provided, then knocks on that port\nto determine when the container is ready for readiness and\nliveness probe checks.\nOtherwise, no startup probe is defined.",
                      "description": "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully"
                    },
                    "volumeMounts": {
                      "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
                      "items": {
                        "$ref": "#/definitions/VolumeMount"
                      },
                      "type": "array"
                    },
                    "workingDir": {
                      "default": "- The container runtime's default.",
                      "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "containers": {
                  "default": "- No containers. Note that a pod spec must include at least one container.",
                  "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod.\n\nYou can add additionnal containers using `podSpec.addContainer()`",
                  "items": {
                    "$ref": "#/definitions/ContainerProps"
                  },
                  "type": "array"
                },
                "dns": {
                  "$ref": "#/definitions/PodDnsProps",
                  "default": " policy: DnsPolicy.CLUSTER_FIRST\n hostnameAsFQDN: false",
                  "description": "DNS settings for the pod."
                },
                "dockerRegistryAuth": {
                  "$ref": "#/definitions/ISecret",
                  "default": "- No auth. Images are assumed to be publicly available.",
                  "description": "A secret containing docker credentials for authenticating to a registry."
                },
                "hostAliases": {
                  "description": "HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.",
                  "items": {
                    "$ref": "#/definitions/HostAlias"
                  },
                  "type": "array"
                },
                "hostNetwork": {
                  "default": false,
                  "description": "Host network for the pod.",
                  "type": "boolean"
                },
                "image": {
                  "$ref": "#/definitions/ContainerImageProps"
                },
                "initContainers": {
                  "default": "- No init containers.",
                  "description": "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion.\n\nInit containers cannot currently be added ,removed or updated.",
                  "items": {
                    "$ref": "#/definitions/ContainerProps"
                  },
                  "type": "array"
                },
                "isolate": {
                  "default": false,
                  "description": "Isolates the pod. This will prevent any ingress or egress connections to / from this pod. You can however allow explicit connections post instantiation by using the `.connections` property.",
                  "type": "boolean"
                },
                "metadata": {
                  "$ref": "#/definitions/ApiObjectMetadata",
                  "description": "Metadata that all persisted resources must have, which includes all objects users must create."
                },
                "podMetadata": {
                  "$ref": "#/definitions/ApiObjectMetadata",
                  "description": "The pod metadata of this workload."
                },
                "probes": {
                  "additionalProperties": false,
                  "properties": {
                    "liveness": {
                      "$ref": "#/definitions/Probe",
                      "default": "- no liveness probe is defined",
                      "description": "Periodic probe of container liveness. Container will be restarted if the probe fails."
                    },
                    "readiness": {
                      "$ref": "#/definitions/Probe",
                      "default": "- no readiness probe is defined",
                      "description": "Determines when the container is ready to serve traffic."
                    },
                    "startup": {
                      "$ref": "#/definitions/Probe",
                      "default": "- If a port is provided, then knocks on that port\nto determine when the container is ready for readiness and\nliveness probe checks.\nOtherwise, no startup probe is defined.",
                      "description": "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully"
                    }
                  },
                  "type": "object"
                },
                "replicaCount": {
                  "type": "number"
                },
                "restartPolicy": {
                  "$ref": "#/definitions/RestartPolicy",
                  "default": "RestartPolicy.ALWAYS",
                  "description": "Restart policy for all containers within the pod."
                },
                "scaling": {
                  "$ref": "#/definitions/ComponentScalingProps"
                },
                "securityContext": {
                  "$ref": "#/definitions/PodSecurityContextProps",
                  "default": "  fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS\n  ensureNonRoot: true",
                  "description": "SecurityContext holds pod-level security attributes and common container settings."
                },
                "select": {
                  "default": true,
                  "description": "Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template.",
                  "type": "boolean"
                },
                "serviceAccount": {
                  "$ref": "#/definitions/IServiceAccount",
                  "default": "- No service account.",
                  "description": "A service account provides an identity for processes that run in a Pod.\n\nWhen you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default)."
                },
                "spread": {
                  "default": false,
                  "description": "Automatically spread pods across hostname and zones.",
                  "type": "boolean"
                },
                "terminationGracePeriod": {
                  "$ref": "#/definitions/Duration",
                  "default": "Duration.seconds(30)",
                  "description": "Grace period until the pod is terminated"
                },
                "volumes": {
                  "default": "- No volumes.",
                  "description": "List of volumes that can be mounted by containers belonging to the pod.\n\nYou can also add volumes later using `podSpec.addVolume()`",
                  "items": {
                    "$ref": "#/definitions/Volume"
                  },
                  "type": "array"
                },
                "workers": {
                  "type": "number"
                }
              },
              "type": "object"
            },
            "celery": {
              "additionalProperties": {
                "additionalProperties": false,
                "properties": {
                  "args": {
                    "items": {
                      "type": "string"
                    },
                    "type": "array"
                  },
                  "automountServiceAccountToken": {
                    "default": false,
                    "description": "Indicates whether a service account token should be automatically mounted.",
                    "type": "boolean"
                  },
                  "concurrency": {
                    "type": "number"
                  },
                  "containerDefaults": {
                    "additionalProperties": false,
                    "properties": {
                      "args": {
                        "default": [],
                        "description": "Arguments to the entrypoint. The docker image's CMD is used if `command` is not provided.\n\nVariable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not.\n\nCannot be updated.",
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      },
                      "command": {
                        "default": "- The docker image's ENTRYPOINT.",
                        "description": "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      },
                      "envFrom": {
                        "default": "- No sources.",
                        "description": "List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the `envVariables` property with a duplicate key will take precedence.",
                        "items": {
                          "$ref": "#/definitions/EnvFrom"
                        },
                        "type": "array"
                      },
                      "envVariables": {
                        "additionalProperties": {
                          "$ref": "#/definitions/EnvValue"
                        },
                        "default": "- No environment variables.",
                        "description": "Environment variables to set in the container.",
                        "type": "object"
                      },
                      "image": {
                        "description": "Docker image name.",
                        "type": "string"
                      },
                      "imagePullPolicy": {
                        "$ref": "#/definitions/ImagePullPolicy",
                        "default": "ImagePullPolicy.ALWAYS",
                        "description": "Image pull policy for this container"
                      },
                      "lifecycle": {
                        "$ref": "#/definitions/ContainerLifecycle",
                        "description": "Describes actions that the management system should take in response to container lifecycle events."
                      },
                      "liveness": {
                        "$ref": "#/definitions/Probe",
                        "default": "- no liveness probe is defined",
                        "description": "Periodic probe of container liveness. Container will be restarted if the probe fails."
                      },
                      "name": {
                        "default": "main",
                        "description": "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
                        "type": "string"
                      },
                      "port": {
                        "deprecated": "- use `portNumber`.",
                        "type": "number"
                      },
                      "portNumber": {
                        "default": "- Only the ports mentiond in the `ports` property are exposed.",
                        "description": "Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.\n\nThis is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the `ports` property.\n\nThis port is added to the list of ports mentioned in the `ports` property.",
                        "type": "number"
                      },
                      "ports": {
                        "default": "- Only the port mentioned in the `portNumber` property is exposed.",
                        "description": "List of ports to expose from this container.",
                        "items": {
                          "$ref": "#/definitions/ContainerPort"
                        },
                        "type": "array"
                      },
                      "readiness": {
                        "$ref": "#/definitions/Probe",
                        "default": "- no readiness probe is defined",
                        "description": "Determines when the container is ready to serve traffic."
                      },
                      "resources": {
                        "$ref": "#/definitions/ContainerResources",
                        "default": "   cpu:\n     request: 1000 millis\n     limit: 1500 millis\n   memory:\n     request: 512 mebibytes\n     limit: 2048 mebibytes",
                        "description": "Compute resources (CPU and memory requests and limits) required by the container"
                      },
                      "securityContext": {
                        "$ref": "#/definitions/ContainerSecurityContextProps",
                        "default": "  ensureNonRoot: true\n  privileged: false\n  readOnlyRootFilesystem: true\n  allowPrivilegeEscalation: false\n  user: 25000\n  group: 26000",
                        "description": "SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod's security context."
                      },
                      "startup": {
                        "$ref": "#/definitions/Probe",
                        "default": "- If a port is provided, then knocks on that port\nto determine when the container is ready for readiness and\nliveness probe checks.\nOtherwise, no startup probe is defined.",
                        "description": "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully"
                      },
                      "volumeMounts": {
                        "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
                        "items": {
                          "$ref": "#/definitions/VolumeMount"
                        },
                        "type": "array"
                      },
                      "workingDir": {
                        "default": "- The container runtime's default.",
                        "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
                        "type": "string"
                      }
                    },
                    "type": "object"
                  },
                  "containers": {
                    "default": "- No containers. Note that a pod spec must include at least one container.",
                    "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod.\n\nYou can add additionnal containers using `podSpec.addContainer()`",
                    "items": {
                      "$ref": "#/definitions/ContainerProps"
                    },
                    "type": "array"
                  },
                  "dns": {
                    "$ref": "#/definitions/PodDnsProps",
                    "default": " policy: DnsPolicy.CLUSTER_FIRST\n hostnameAsFQDN: false",
                    "description": "DNS settings for the pod."
                  },
                  "dockerRegistryAuth": {
                    "$ref": "#/definitions/ISecret",
                    "default": "- No auth. Images are assumed to be publicly available.",
                    "description": "A secret containing docker credentials for authenticating to a registry."
                  },
                  "hostAliases": {
                    "description": "HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.",
                    "items": {
                      "$ref": "#/definitions/HostAlias"
                    },
                    "type": "array"
                  },
                  "hostNetwork": {
                    "default": false,
                    "description": "Host network for the pod.",
                    "type": "boolean"
                  },
                  "image": {
                    "$ref": "#/definitions/ContainerImageProps"
                  },
                  "initContainers": {
                    "default": "- No init containers.",
                    "description": "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion.\n\nInit containers cannot currently be added ,removed or updated.",
                    "items": {
                      "$ref": "#/definitions/ContainerProps"
                    },
                    "type": "array"
                  },
                  "isolate": {
                    "default": false,
                    "description": "Isolates the pod. This will prevent any ingress or egress connections to / from this pod. You can however allow explicit connections post instantiation by using the `.connections` property.",
                    "type": "boolean"
                  },
                  "metadata": {
                    "$ref": "#/definitions/ApiObjectMetadata",
                    "description": "Metadata that all persisted resources must have, which includes all objects users must create."
                  },
                  "name": {
                    "type": "string"
                  },
                  "podMetadata": {
                    "$ref": "#/definitions/ApiObjectMetadata",
                    "description": "The pod metadata of this workload."
                  },
                  "probes": {
                    "additionalProperties": false,
                    "properties": {
                      "liveness": {
                        "$ref": "#/definitions/Probe",
                        "default": "- no liveness probe is defined",
                        "description": "Periodic probe of container liveness. Container will be restarted if the probe fails."
                      },
                      "readiness": {
                        "$ref": "#/definitions/Probe",
                        "default": "- no readiness probe is defined",
                        "description": "Determines when the container is ready to serve traffic."
                      },
                      "startup": {
                        "$ref": "#/definitions/Probe",
                        "default": "- If a port is provided, then knocks on that port\nto determine when the container is ready for readiness and\nliveness probe checks.\nOtherwise, no startup probe is defined.",
                        "description": "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully"
                      }
                    },
                    "type": "object"
                  },
                  "queues": {
                    "items": {
                      "type": "string"
                    },
                    "type": "array"
                  },
                  "replicaCount": {
                    "type": "number"
                  },
                  "restartPolicy": {
                    "$ref": "#/definitions/RestartPolicy",
                    "default": "RestartPolicy.ALWAYS",
                    "description": "Restart policy for all containers within the pod."
                  },
                  "scaling": {
                    "$ref": "#/definitions/ComponentScalingProps"
                  },
                  "securityContext": {
                    "$ref": "#/definitions/PodSecurityContextProps",
                    "default": "  fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS\n  ensureNonRoot: true",
                    "description": "SecurityContext holds pod-level security attributes and common container settings."
                  },
                  "select": {
                    "default": true,
                    "description": "Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template.",
                    "type": "boolean"
                  },
                  "serviceAccount": {
                    "$ref": "#/definitions/IServiceAccount",
                    "default": "- No service account.",
                    "description": "A service account provides an identity for processes that run in a Pod.\n\nWhen you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default)."
                  },
                  "spread": {
                    "default": false,
                    "description": "Automatically spread pods across hostname and zones.",
                    "type": "boolean"
                  },
                  "terminationGracePeriod": {
                    "$ref": "#/definitions/Duration",
                    "default": "Duration.seconds(30)",
                    "description": "Grace period until the pod is terminated"
                  },
                  "volumes": {
                    "default": "- No volumes.",
                    "description": "List of volumes that can be mounted by containers belonging to the pod.\n\nYou can also add volumes later using `podSpec.addVolume()`",
                    "items": {
                      "$ref": "#/definitions/Volume"
                    },
                    "type": "array"
                  }
                },
                "required": [],
                "type": "object"
              },
              "type": "object"
            },
            "celeryBeat": {
              "additionalProperties": false,
              "properties": {
                "automountServiceAccountToken": {
                  "default": false,
                  "description": "Indicates whether a service account token should be automatically mounted.",
                  "type": "boolean"
                },
                "containerDefaults": {
                  "additionalProperties": false,
                  "properties": {
                    "args": {
                      "default": [],
                      "description": "Arguments to the entrypoint. The docker image's CMD is used if `command` is not provided.\n\nVariable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not.\n\nCannot be updated.",
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "command": {
                      "default": "- The docker image's ENTRYPOINT.",
                      "description": "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "envFrom": {
                      "default": "- No sources.",
                      "description": "List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the `envVariables` property with a duplicate key will take precedence.",
                      "items": {
                        "$ref": "#/definitions/EnvFrom"
                      },
                      "type": "array"
                    },
                    "envVariables": {
                      "additionalProperties": {
                        "$ref": "#/definitions/EnvValue"
                      },
                      "default": "- No environment variables.",
                      "description": "Environment variables to set in the container.",
                      "type": "object"
                    },
                    "image": {
                      "description": "Docker image name.",
                      "type": "string"
                    },
                    "imagePullPolicy": {
                      "$ref": "#/definitions/ImagePullPolicy",
                      "default": "ImagePullPolicy.ALWAYS",
                      "description": "Image pull policy for this container"
                    },
                    "lifecycle": {
                      "$ref": "#/definitions/ContainerLifecycle",
                      "description": "Describes actions that the management system should take in response to container lifecycle events."
                    },
                    "liveness": {
                      "$ref": "#/definitions/Probe",
                      "default": "- no liveness probe is defined",
                      "description": "Periodic probe of container liveness. Container will be restarted if the probe fails."
                    },
                    "name": {
                      "default": "main",
                      "description": "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
                      "type": "string"
                    },
                    "port": {
                      "deprecated": "- use `portNumber`.",
                      "type": "number"
                    },
                    "portNumber": {
                      "default": "- Only the ports mentiond in the `ports` property are exposed.",
                      "description": "Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.\n\nThis is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the `ports` property.\n\nThis port is added to the list of ports mentioned in the `ports` property.",
                      "type": "number"
                    },
                    "ports": {
                      "default": "- Only the port mentioned in the `portNumber` property is exposed.",
                      "description": "List of ports to expose from this container.",
                      "items": {
                        "$ref": "#/definitions/ContainerPort"
                      },
                      "type": "array"
                    },
                    "readiness": {
                      "$ref": "#/definitions/Probe",
                      "default": "- no readiness probe is defined",
                      "description": "Determines when the container is ready to serve traffic."
                    },
                    "resources": {
                      "$ref": "#/definitions/ContainerResources",
                      "default": "   cpu:\n     request: 1000 millis\n     limit: 1500 millis\n   memory:\n     request: 512 mebibytes\n     limit: 2048 mebibytes",
                      "description": "Compute resources (CPU and memory requests and limits) required by the container"
                    },
                    "securityContext": {
                      "$ref": "#/definitions/ContainerSecurityContextProps",
                      "default": "  ensureNonRoot: true\n  privileged: false\n  readOnlyRootFilesystem: true\n  allowPrivilegeEscalation: false\n  user: 25000\n  group: 26000",
                      "description": "SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod's security context."
                    },
                    "startup": {
                      "$ref": "#/definitions/Probe",
                      "default": "- If a port is provided, then knocks on that port\nto determine when the container is ready for readiness and\nliveness probe checks.\nOtherwise, no startup probe is defined.",
                      "description": "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully"
                    },
                    "volumeMounts": {
                      "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
                      "items": {
                        "$ref": "#/definitions/VolumeMount"
                      },
                      "type": "array"
                    },
                    "workingDir": {
                      "default": "- The container runtime's default.",
                      "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "containers": {
                  "default": "- No containers. Note that a pod spec must include at least one container.",
                  "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod.\n\nYou can add additionnal containers using `podSpec.addContainer()`",
                  "items": {
                    "$ref": "#/definitions/ContainerProps"
                  },
                  "type": "array"
                },
                "dns": {
                  "$ref": "#/definitions/PodDnsProps",
                  "default": " policy: DnsPolicy.CLUSTER_FIRST\n hostnameAsFQDN: false",
                  "description": "DNS settings for the pod."
                },
                "dockerRegistryAuth": {
                  "$ref": "#/definitions/ISecret",
                  "default": "- No auth. Images are assumed to be publicly available.",
                  "description": "A secret containing docker credentials for authenticating to a registry."
                },
                "hostAliases": {
                  "description": "HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.",
                  "items": {
                    "$ref": "#/definitions/HostAlias"
                  },
                  "type": "array"
                },
                "hostNetwork": {
                  "default": false,
                  "description": "Host network for the pod.",
                  "type": "boolean"
                },
                "image": {
                  "$ref": "#/definitions/ContainerImageProps"
                },
                "initContainers": {
                  "default": "- No init containers.",
                  "description": "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion.\n\nInit containers cannot currently be added ,removed or updated.",
                  "items": {
                    "$ref": "#/definitions/ContainerProps"
                  },
                  "type": "array"
                },
                "isolate": {
                  "default": false,
                  "description": "Isolates the pod. This will prevent any ingress or egress connections to / from this pod. You can however allow explicit connections post instantiation by using the `.connections` property.",
                  "type": "boolean"
                },
                "metadata": {
                  "$ref": "#/definitions/ApiObjectMetadata",
                  "description": "Metadata that all persisted resources must have, which includes all objects users must create."
                },
                "podMetadata": {
                  "$ref": "#/definitions/ApiObjectMetadata",
                  "description": "The pod metadata of this workload."
                },
                "probes": {
                  "additionalProperties": false,
                  "properties": {
                    "liveness": {
                      "$ref": "#/definitions/Probe",
                      "default": "- no liveness probe is defined",
                      "description": "Periodic probe of container liveness. Container will be restarted if the probe fails."
                    },
                    "readiness": {
                      "$ref": "#/definitions/Probe",
                      "default": "- no readiness probe is defined",
                      "description": "Determines when the container is ready to serve traffic."
                    },
                    "startup": {
                      "$ref": "#/definitions/Probe",
                      "default": "- If a port is provided, then knocks on that port\nto determine when the container is ready for readiness and\nliveness probe checks.\nOtherwise, no startup probe is defined.",
                      "description": "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully"
                    }
                  },
                  "type": "object"
                },
                "replicaCount": {
                  "type": "number"
                },
                "restartPolicy": {
                  "$ref": "#/definitions/RestartPolicy",
                  "default": "RestartPolicy.ALWAYS",
                  "description": "Restart policy for all containers within the pod."
                },
                "scaling": {
                  "$ref": "#/definitions/ComponentScalingProps"
                },
                "securityContext": {
                  "$ref": "#/definitions/PodSecurityContextProps",
                  "default": "  fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS\n  ensureNonRoot: true",
                  "description": "SecurityContext holds pod-level security attributes and common container settings."
                },
                "select": {
                  "default": true,
                  "description": "Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template.",
                  "type": "boolean"
                },
                "serviceAccount": {
                  "$ref": "#/definitions/IServiceAccount",
                  "default": "- No service account.",
                  "description": "A service account provides an identity for processes that run in a Pod.\n\nWhen you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default)."
                },
                "spread": {
                  "default": false,
                  "description": "Automatically spread pods across hostname and zones.",
                  "type": "boolean"
                },
                "terminationGracePeriod": {
                  "$ref": "#/definitions/Duration",
                  "default": "Duration.seconds(30)",
                  "description": "Grace period until the pod is terminated"
                },
                "volumes": {
                  "default": "- No volumes.",
                  "description": "List of volumes that can be mounted by containers belonging to the pod.\n\nYou can also add volumes later using `podSpec.addVolume()`",
                  "items": {
                    "$ref": "#/definitions/Volume"
                  },
                  "type": "array"
                }
              },
              "type": "object"
            },
            "disableResourceNameHashes": {
              "default": false,
              "description": "The autogenerated resource name by default is suffixed with a stable hash of the construct path. Setting this property to true drops the hash suffix.",
              "type": "boolean"
            },
            "domainName": {
              "type": "string"
            },
            "frontend": {
              "$ref": "#/definitions/FrontendProps"
            },
            "ingressAnnotations": {
              "additionalProperties": {
                "type": "string"
              },
              "type": "object"
            },
            "labels": {
              "additionalProperties": {
                "type": "string"
              },
              "default": "- no common labels",
              "description": "Labels to apply to all resources in this chart.",
              "type": "object"
            },
            "namespace": {
              "default": "- no namespace is synthesized (usually this implies \"default\")",
              "description": "The default namespace for all objects defined in this chart (directly or indirectly). This namespace will only apply to objects that don't have a `namespace` explicitly defined for them.",
              "type": "string"
            },
            "webImage": {
              "$ref": "#/definitions/ContainerImageProps"
            },
            "wsgi": {
              "additionalProperties": false,
              "properties": {
                "automountServiceAccountToken": {
                  "default": false,
                  "description": "Indicates whether a service account token should be automatically mounted.",
                  "type": "boolean"
                },
                "containerDefaults": {
                  "additionalProperties": false,
                  "properties": {
                    "args": {
                      "default": [],
                      "description": "Arguments to the entrypoint. The docker image's CMD is used if `command` is not provided.\n\nVariable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not.\n\nCannot be updated.",
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "command": {
                      "default": "- The docker image's ENTRYPOINT.",
                      "description": "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "envFrom": {
                      "default": "- No sources.",
                      "description": "List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the `envVariables` property with a duplicate key will take precedence.",
                      "items": {
                        "$ref": "#/definitions/EnvFrom"
                      },
                      "type": "array"
                    },
                    "envVariables": {
                      "additionalProperties": {
                        "$ref": "#/definitions/EnvValue"
                      },
                      "default": "- No environment variables.",
                      "description": "Environment variables to set in the container.",
                      "type": "object"
                    },
                    "image": {
                      "description": "Docker image name.",
                      "type": "string"
                    },
                    "imagePullPolicy": {
                      "$ref": "#/definitions/ImagePullPolicy",
                      "default": "ImagePullPolicy.ALWAYS",
                      "description": "Image pull policy for this container"
                    },
                    "lifecycle": {
                      "$ref": "#/definitions/ContainerLifecycle",
                      "description": "Describes actions that the management system should take in response to container lifecycle events."
                    },
                    "liveness": {
                      "$ref": "#/definitions/Probe",
                      "default": "- no liveness probe is defined",
                      "description": "Periodic probe of container liveness. Container will be restarted if the probe fails."
                    },
                    "name": {
                      "default": "main",
                      "description": "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
                      "type": "string"
                    },
                    "port": {
                      "deprecated": "- use `portNumber`.",
                      "type": "number"
                    },
                    "portNumber": {
                      "default": "- Only the ports mentiond in the `ports` property are exposed.",
                      "description": "Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.\n\nThis is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the `ports` property.\n\nThis port is added to the list of ports mentioned in the `ports` property.",
                      "type": "number"
                    },
                    "ports": {
                      "default": "- Only the port mentioned in the `portNumber` property is exposed.",
                      "description": "List of ports to expose from this container.",
                      "items": {
                        "$ref": "#/definitions/ContainerPort"
                      },
                      "type": "array"
                    },
                    "readiness": {
                      "$ref": "#/definitions/Probe",
                      "default": "- no readiness probe is defined",
                      "description": "Determines when the container is ready to serve traffic."
                    },
                    "resources": {
                      "$ref": "#/definitions/ContainerResources",
                      "default": "   cpu:\n     request: 1000 millis\n     limit: 1500 millis\n   memory:\n     request: 512 mebibytes\n     limit: 2048 mebibytes",
                      "description": "Compute resources (CPU and memory requests and limits) required by the container"
                    },
                    "securityContext": {
                      "$ref": "#/definitions/ContainerSecurityContextProps",
                      "default": "  ensureNonRoot: true\n  privileged: false\n  readOnlyRootFilesystem: true\n  allowPrivilegeEscalation: false\n  user: 25000\n  group: 26000",
                      "description": "SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod's security context."
                    },
                    "startup": {
                      "$ref": "#/definitions/Probe",
                      "default": "- If a port is provided, then knocks on that port\nto determine when the container is ready for readiness and\nliveness probe checks.\nOtherwise, no startup probe is defined.",
                      "description": "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully"
                    },
                    "volumeMounts": {
                      "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
                      "items": {
                        "$ref": "#/definitions/VolumeMount"
                      },
                      "type": "array"
                    },
                    "workingDir": {
                      "default": "- The container runtime's default.",
                      "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "containers": {
                  "default": "- No containers. Note that a pod spec must include at least one container.",
                  "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod.\n\nYou can add additionnal containers using `podSpec.addContainer()`",
                  "items": {
                    "$ref": "#/definitions/ContainerProps"
                  },
                  "type": "array"
                },
                "dns": {
                  "$ref": "#/definitions/PodDnsProps",
                  "default": " policy: DnsPolicy.CLUSTER_FIRST\n hostnameAsFQDN: false",
                  "description": "DNS settings for the pod."
                },
                "dockerRegistryAuth": {
                  "$ref": "#/definitions/ISecret",
                  "default": "- No auth. Images are assumed to be publicly available.",
                  "description": "A secret containing docker credentials for authenticating to a registry."
                },
                "hostAliases": {
                  "description": "HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.",
                  "items": {
                    "$ref": "#/definitions/HostAlias"
                  },
                  "type": "array"
                },
                "hostNetwork": {
                  "default": false,
                  "description": "Host network for the pod.",
                  "type": "boolean"
                },
                "image": {
                  "$ref": "#/definitions/ContainerImageProps"
                },
                "initContainers": {
                  "default": "- No init containers.",
                  "description": "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion.\n\nInit containers cannot currently be added ,removed or updated.",
                  "items": {
                    "$ref": "#/definitions/ContainerProps"
                  },
                  "type": "array"
                },
                "isolate": {
                  "default": false,
                  "description": "Isolates the pod. This will prevent any ingress or egress connections to / from this pod. You can however allow explicit connections post instantiation by using the `.connections` property.",
                  "type": "boolean"
                },
                "metadata": {
                  "$ref": "#/definitions/ApiObjectMetadata",
                  "description": "Metadata that all persisted resources must have, which includes all objects users must create."
                },
                "podMetadata": {
                  "$ref": "#/definitions/ApiObjectMetadata",
                  "description": "The pod metadata of this workload."
                },
                "probes": {
                  "additionalProperties": false,
                  "properties": {
                    "liveness": {
                      "$ref": "#/definitions/Probe",
                      "default": "- no liveness probe is defined",
                      "description": "Periodic probe of container liveness. Container will be restarted if the probe fails."
                    },
                    "readiness": {
                      "$ref": "#/definitions/Probe",
                      "default": "- no readiness probe is defined",
                      "description": "Determines when the container is ready to serve traffic."
                    },
                    "startup": {
                      "$ref": "#/definitions/Probe",
                      "default": "- If a port is provided, then knocks on that port\nto determine when the container is ready for readiness and\nliveness probe checks.\nOtherwise, no startup probe is defined.",
                      "description": "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully"
                    }
                  },
                  "type": "object"
                },
                "replicaCount": {
                  "type": "number"
                },
                "restartPolicy": {
                  "$ref": "#/definitions/RestartPolicy",
                  "default": "RestartPolicy.ALWAYS",
                  "description": "Restart policy for all containers within the pod."
                },
                "scaling": {
                  "$ref": "#/definitions/ComponentScalingProps"
                },
                "securityContext": {
                  "$ref": "#/definitions/PodSecurityContextProps",
                  "default": "  fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS\n  ensureNonRoot: true",
                  "description": "SecurityContext holds pod-level security attributes and common container settings."
                },
                "select": {
                  "default": true,
                  "description": "Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template.",
                  "type": "boolean"
                },
                "serviceAccount": {
                  "$ref": "#/definitions/IServiceAccount",
                  "default": "- No service account.",
                  "description": "A service account provides an identity for processes that run in a Pod.\n\nWhen you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default)."
                },
                "spread": {
                  "default": false,
                  "description": "Automatically spread pods across hostname and zones.",
                  "type": "boolean"
                },
                "terminationGracePeriod": {
                  "$ref": "#/definitions/Duration",
                  "default": "Duration.seconds(30)",
                  "description": "Grace period until the pod is terminated"
                },
                "threads": {
                  "type": "number"
                },
                "volumes": {
                  "default": "- No volumes.",
                  "description": "List of volumes that can be mounted by containers belonging to the pod.\n\nYou can also add volumes later using `podSpec.addVolume()`",
                  "items": {
                    "$ref": "#/definitions/Volume"
                  },
                  "type": "array"
                },
                "workers": {
                  "type": "number"
                }
              },
              "type": "object"
            }
          },
          "required": [
            "domainName"
          ],
          "type": "object"
        }
      },
      "required": [],
      "type": "object"
    },
    "Stage": {
      "enum": [
        "local",
        "development",
        "staging",
        "production"
      ],
      "type": "string"
    }
  }
}
